import 'package:flutter/material.dart';
import 'dart:math' as math;
import '../holographic/holographic_widget.dart';
import '../holographic/holographic_theme.dart';

/// Individual key that can be moved independently
class SplitKey {
  final int midiNote;
  final String noteName;
  final bool isBlackKey;
  Offset position;
  Size size;
  bool isPressed;
  double velocity;
  double initialTouchY = 0.0;
  double currentAftertouchValue = 0.0;
  Offset? lastTapDownPosition; // For X-axis hit position visual
  
  SplitKey({
    required this.midiNote,
    required this.noteName,
    required this.isBlackKey,
    required this.position,
    required this.size,
    this.isPressed = false,
    this.velocity = 0.0,
  });
}

/// A holographic, interactive musical keyboard.
///
/// Features:
/// - Standard piano layout, configurable for octave range and key width.
/// - "Split Mode" allowing individual keys to be repositioned (visual only, not functional for separate MIDI channels).
/// - Dynamic velocity sensitivity based on the Y-position of the touch on a key.
/// - Polyphonic Aftertouch: Y-axis sliding on a pressed key generates aftertouch values for that specific note.
///   The [onPolyAftertouch] callback returns a record `({int note, double value})` where `value`
///   is the normalized aftertouch (0.0-1.0).
/// - **Hit Position Feedback:** A brief visual effect (e.g., a flare or ripple, intended to be drawn
///   by `_KeyHitEffectPainter`) emanates from the point of touch (X-Y on the key surface).
///   This is managed by per-key `AnimationController`s (`_hitEffectControllers`) in the state.
/// - **Duration (Hold) Feedback:** While a key is pressed, its glow intensity subtly pulses,
///   controlled by per-key `AnimationController`s (`_holdPulseControllers`).
/// - Visual feedback on keys for press state, velocity, and aftertouch (e.g., glow intensity, color shifts, indicator bar).
/// - Includes pitch bend and modulation wheel controls.
class HolographicKeyboard extends StatefulWidget {
  final int octaveRange;
  final double keyWidth;
  final bool splitMode;
  final ValueChanged<int>? onNoteOn;
  final ValueChanged<int>? onNoteOff;
  final ValueChanged<double>? onPitchBend;
  final ValueChanged<double>? onModulation;
  final ValueChanged<int>? onOctaveChanged;
  final ValueChanged<double>? onKeyWidthChanged;
  final ValueChanged<bool>? onSplitModeChanged;
  final Color energyColor;
  final ValueChanged<({int note, double value})>? onPolyAftertouch; // New callback
  
  /// Creates a HolographicKeyboard.
  ///
  /// Callbacks like [onNoteOn], [onNoteOff], and [onPolyAftertouch] provide MIDI-like event data.
  /// The [onPolyAftertouch] callback uses a record `({int note, double value})` where `value`
  /// is the normalized aftertouch (0.0-1.0) generated by sliding vertically on a pressed key.
  const HolographicKeyboard({
    Key? key,
    this.octaveRange = 4,
    this.keyWidth = 40.0,
    this.splitMode = false,
    this.onNoteOn,
    this.onNoteOff,
    this.onPitchBend,
    this.onModulation,
    this.onOctaveChanged,
    this.onKeyWidthChanged,
    this.onSplitModeChanged,
    this.energyColor = HolographicTheme.secondaryEnergy,
    this.onPolyAftertouch, // New callback
  }) : super(key: key);
  
  @override
  State<HolographicKeyboard> createState() => _HolographicKeyboardState();
}

class _HolographicKeyboardState extends State<HolographicKeyboard>
    with TickerProviderStateMixin {
  
  late AnimationController _glowController;
  late Animation<double> _glowAnimation;

  // Maps to manage controllers per key (using MIDI note as key)
  final Map<int, AnimationController> _hitEffectControllers = {};
  final Map<int, Animation<double>> _hitEffectAnimations = {};
  final Map<int, AnimationController> _holdPulseControllers = {};
  final Map<int, Animation<double>> _holdPulseAnimations = {};
  
  List<SplitKey> _keys = [];
  double _pitchBendValue = 0.0;
  double _modulationValue = 0.0;
  Set<int> _pressedKeys = {};
  
  // Bendwheel positions
  Offset _pitchWheelPosition = const Offset(20, 100);
  Offset _modWheelPosition = const Offset(60, 100);
  
  @override
  void initState() {
    super.initState();
    
    _glowController = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: this,
    );
    _glowAnimation = Tween<double>(begin: 0.6, end: 1.0).animate(
      CurvedAnimation(parent: _glowController, curve: Curves.easeInOut),
    );
    _glowController.repeat(reverse: true);
    
    _generateKeys();
  }
  
  @override
  void didUpdateWidget(HolographicKeyboard oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.octaveRange != widget.octaveRange ||
        oldWidget.keyWidth != widget.keyWidth) {
      _generateKeys();
    }
  }
  
  @override
  void dispose() {
    _glowController.dispose();
    _hitEffectControllers.forEach((_, controller) => controller.dispose());
    _holdPulseControllers.forEach((_, controller) => controller.dispose());
    super.dispose();
  }
  
  void _generateKeys() {
    _keys.clear();
    
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const blackKeyPattern = [false, true, false, true, false, false, true, false, true, false, true, false];
    
    double whiteKeyOffset = 0;
    
    for (int octave = 0; octave < 2; octave++) {
      for (int note = 0; note < 12; note++) {
        final midiNote = (widget.octaveRange * 12) + (octave * 12) + note;
        final noteName = noteNames[note] + (widget.octaveRange + octave).toString();
        final isBlackKey = blackKeyPattern[note];
        
        if (isBlackKey) {
          // Black key - positioned between white keys
          _keys.add(SplitKey(
            midiNote: midiNote,
            noteName: noteName,
            isBlackKey: true,
            position: Offset(
              whiteKeyOffset - (widget.keyWidth * 0.3),
              0,
            ),
            size: Size(widget.keyWidth * 0.6, 80),
          ));
        } else {
          // White key
          _keys.add(SplitKey(
            midiNote: midiNote,
            noteName: noteName,
            isBlackKey: false,
            position: Offset(whiteKeyOffset, 0),
            size: Size(widget.keyWidth, 120),
          ));
          whiteKeyOffset += widget.keyWidth;
        }
      }
    }
  }
  
  void _onKeyPressed(SplitKey key, double velocity, Offset localTapPosition) {
    setState(() {
      key.isPressed = true;
      key.velocity = velocity;
      key.initialTouchY = localTapPosition.dy;
      key.currentAftertouchValue = 0.0;
      key.lastTapDownPosition = localTapPosition; // Store for hit effect painter
      _pressedKeys.add(key.midiNote);

      // Hit Effect Initialization
      _hitEffectControllers[key.midiNote]?.dispose(); // Dispose previous controller for this key
      final hitCtrl = AnimationController(duration: const Duration(milliseconds: 350), vsync: this);
      _hitEffectControllers[key.midiNote] = hitCtrl;
      _hitEffectAnimations[key.midiNote] = CurvedAnimation(parent: hitCtrl, curve: Curves.easeOutCubic)
        ..addListener(() => setState(() {})) // Trigger rebuild on animation ticks
        ..addStatusListener((status) { // Auto-dispose controller and clear lastTapDownPosition
          if (status == AnimationStatus.completed || status == AnimationStatus.dismissed) {
            if (mounted) {
              // Only clear lastTapDownPosition if the key is no longer pressed,
              // or if this specific animation instance is finishing.
              // This handles cases where a key might be re-triggered quickly.
              if (!key.isPressed || _hitEffectControllers[key.midiNote] == hitCtrl) {
                 setState(() { key.lastTapDownPosition = null; });
              }
            }
            if (_hitEffectControllers[key.midiNote] == hitCtrl) { // Ensure it's the same controller
              hitCtrl.dispose();
              _hitEffectControllers.remove(key.midiNote);
              _hitEffectAnimations.remove(key.midiNote);
            }
          }
        });
      hitCtrl.forward(from: 0.0);

      // Hold Pulse Effect Initialization
      _holdPulseControllers[key.midiNote]?.dispose(); // Dispose previous controller
      final holdCtrl = AnimationController(duration: const Duration(milliseconds: 1200), vsync: this);
      _holdPulseControllers[key.midiNote] = holdCtrl;
      _holdPulseAnimations[key.midiNote] = Tween<double>(begin: 0.85, end: 1.15).animate(
        CurvedAnimation(parent: holdCtrl, curve: Curves.easeInOut)
      )..addListener(() => setState(() {})); // Trigger rebuild
      holdCtrl.repeat(reverse: true);
    });
    widget.onNoteOn?.call(key.midiNote, velocity);
  }
  
  void _onKeyReleased(SplitKey key) {
    if (key.isPressed) {
      if (key.currentAftertouchValue != 0.0) {
        widget.onPolyAftertouch?.call((note: key.midiNote, value: 0.0));
      }

      _holdPulseControllers[key.midiNote]?.stop();
      _holdPulseControllers[key.midiNote]?.dispose(); // Dispose it now as it's no longer needed
      _holdPulseControllers.remove(key.midiNote);
      _holdPulseAnimations.remove(key.midiNote);

      // Hit effect controller is managed by its status listener for disposal.
      // We need to ensure key.isPressed is false so the listener can clear lastTapDownPosition.
      bool hitCtrlIsAnimating = _hitEffectControllers[key.midiNote]?.isAnimating ?? false;

      setState(() {
        key.isPressed = false;
        key.velocity = 0.0;
        key.currentAftertouchValue = 0.0;
        _pressedKeys.remove(key.midiNote);
        // If hit animation is not running (already completed/dismissed) and position still exists, clear it.
        if (!hitCtrlIsAnimating && key.lastTapDownPosition != null) {
           key.lastTapDownPosition = null;
        }
      });
      widget.onNoteOff?.call(key.midiNote);
    }
  }
  
  void _onKeyDragged(SplitKey key, Offset delta) {
    if (widget.splitMode) {
      setState(() {
        key.position += delta;
      });
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return HolographicWidget(
      title: 'KEYBOARD',
      energyColor: widget.energyColor,
      minWidth: 400,
      minHeight: 200,
      child: Column(
        children: [
          // Control panel
          _buildControlPanel(),
          
          // Keyboard area
          Expanded(
            child: Container(
              margin: const EdgeInsets.all(8),
              child: Stack(
                children: [
                  // Keys
                  ..._keys.map((key) => _buildKey(key)),
                  
                  // Pitch bend wheel
                  _buildPitchWheel(),
                  
                  // Modulation wheel
                  _buildModWheel(),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildControlPanel() {
    return Container(
      padding: const EdgeInsets.all(8),
      child: Row(
        children: [
          // Octave selector
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'OCTAVE',
                style: HolographicTheme.createHolographicText(
                  energyColor: widget.energyColor,
                  fontSize: 10,
                ),
              ),
              const SizedBox(height: 4),
              HolographicDropdown<int>(
                value: widget.octaveRange,
                hint: 'Octave',
                energyColor: widget.energyColor,
                items: List.generate(11, (index) {
                  final octave = index - 1;
                  return DropdownMenuItem(
                    value: octave,
                    child: Text(
                      'C$octave',
                      style: HolographicTheme.createHolographicText(
                        energyColor: widget.energyColor,
                        fontSize: 11,
                      ),
                    ),
                  );
                }),
                onChanged: (value) {
                  if (value != null) {
                    widget.onOctaveChanged?.call(value);
                  }
                },
              ),
            ],
          ),
          
          const SizedBox(width: 16),
          
          // Key width slider
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'KEY WIDTH',
                  style: HolographicTheme.createHolographicText(
                    energyColor: widget.energyColor,
                    fontSize: 10,
                  ),
                ),
                const SizedBox(height: 4),
                SliderTheme(
                  data: SliderTheme.of(context).copyWith(
                    activeTrackColor: widget.energyColor,
                    inactiveTrackColor: widget.energyColor.withOpacity(0.3),
                    thumbColor: widget.energyColor,
                    trackHeight: 2.0,
                    thumbShape: const RoundSliderThumbShape(
                      enabledThumbRadius: 6.0,
                    ),
                  ),
                  child: Slider(
                    value: widget.keyWidth,
                    min: 20.0,
                    max: 80.0,
                    onChanged: (value) {
                      widget.onKeyWidthChanged?.call(value);
                    },
                  ),
                ),
              ],
            ),
          ),
          
          const SizedBox(width: 16),
          
          // Split mode toggle
          Column(
            children: [
              Text(
                'SPLIT MODE',
                style: HolographicTheme.createHolographicText(
                  energyColor: widget.energyColor,
                  fontSize: 10,
                ),
              ),
              const SizedBox(height: 4),
              GestureDetector(
                onTap: () {
                  widget.onSplitModeChanged?.call(!widget.splitMode);
                },
                child: Container(
                  width: 40,
                  height: 20,
                  decoration: HolographicTheme.createHolographicBorder(
                    energyColor: widget.energyColor,
                    intensity: widget.splitMode ? 1.5 : 0.7,
                  ),
                  child: AnimatedAlign(
                    duration: const Duration(milliseconds: 200),
                    alignment: widget.splitMode 
                        ? Alignment.centerRight 
                        : Alignment.centerLeft,
                    child: Container(
                      width: 16,
                      height: 16,
                      margin: const EdgeInsets.all(2),
                      decoration: BoxDecoration(
                        color: widget.energyColor,
                        borderRadius: BorderRadius.circular(8),
                        boxShadow: [
                          HolographicTheme.createEnergyGlow(
                            color: widget.energyColor,
                            radius: 4.0,
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  
  Widget _buildKey(SplitKey key) {
    return Positioned(
      left: key.position.dx,
      top: key.position.dy,
      // Use a Builder to get the correct RenderBox for the key to calculate local Y position accurately
      // relative to the key itself, not just the GestureDetector.
      // However, GestureDetector's onTapDown details.localPosition is already relative to the GestureDetector.
      child: GestureDetector(
        onTapDown: (details) {
          if (key.size.height == 0) return;
          final keyHeight = key.size.height;
          final localPos = details.localPosition;
          final localDy = localPos.dy.clamp(0.0, keyHeight);
          final normalizedY = localDy / keyHeight;
          final calculatedVelocity = (normalizedY * 0.8) + 0.2;
          _onKeyPressed(key, calculatedVelocity.clamp(0.1, 1.0), localPos);
        },
        onTapUp: (_) => _onKeyReleased(key),
        onTapCancel: () => _onKeyReleased(key), // Also release on cancel
        onVerticalDragStart: (details) {
          if (key.isPressed) { // Start aftertouch drag on an already pressed key
            setState(() {
              key.initialTouchY = details.localPosition.dy;
            });
          }
        },
        onVerticalDragUpdate: (details) {
          if (key.isPressed && key.size.height > 0) {
            final double deltaY = details.localPosition.dy - key.initialTouchY;
            // Normalize deltaY: range of +/- key.size.height / 2 maps to 0.0-1.0 aftertouch
            // Positive deltaY (sliding down) increases aftertouch.
            double normalizedAftertouch = (deltaY / (key.size.height / 1.5)) / 2.0 + 0.5; // Sensitive over 2/3 of key height
            normalizedAftertouch = normalizedAftertouch.clamp(0.0, 1.0);

            setState(() {
              key.currentAftertouchValue = normalizedAftertouch;
            });
            widget.onPolyAftertouch?.call((note: key.midiNote, value: key.currentAftertouchValue));
          }
        },
        onVerticalDragEnd: (details) {
          if (key.isPressed) {
             // Optionally reset aftertouch to 0 on drag end, or let it persist until key up
            // widget.onPolyAftertouch?.call((note: key.midiNote, value: 0.0));
            // setState(() { key.currentAftertouchValue = 0.0; });
          }
        },
        onPanUpdate: widget.splitMode 
            ? (details) => _onKeyDragged(key, details.delta) // Horizontal pan for split mode
            : null, // Disable horizontal pan if not in split mode to prioritize vertical drag

        child: AnimatedBuilder(
          animation: Listenable.merge([
            _glowAnimation,
            _hitEffectAnimations[key.midiNote],
            _holdPulseAnimations[key.midiNote]
          ].whereType<Animation<double>>().toList()),
          builder: (context, child) {
            double currentGlowIntensity = _glowAnimation.value;
            if (key.isPressed && _holdPulseAnimations[key.midiNote] != null) {
              currentGlowIntensity = _holdPulseAnimations[key.midiNote]!.value;
            }
            final finalGlowIntensity = key.isPressed
                ? (currentGlowIntensity + key.currentAftertouchValue * 1.0).clamp(0.5, 2.5)
                : _glowAnimation.value;
            
            Color keyMainColor = key.isBlackKey
                    ? Colors.black.withOpacity(0.7)
                    : Colors.white.withOpacity(0.1);

            if(key.isPressed) {
              keyMainColor = Color.lerp(keyMainColor, widget.energyColor, (key.currentAftertouchValue * 0.3).clamp(0.0, 0.3))!;
            }

            return Container(
              width: key.size.width,
              height: key.size.height,
              decoration: BoxDecoration(
                color: keyMainColor,
                borderRadius: BorderRadius.circular(4),
                border: Border.all(
                  color: widget.energyColor.withOpacity(
                    key.isPressed ? (0.8 + key.currentAftertouchValue * 0.2).clamp(0.8,1.0) : 0.6,
                  ),
                  width: key.isPressed ? (1.5 + key.currentAftertouchValue).clamp(1.5, 2.5) : 1.0,
                ),
                boxShadow: [
                  HolographicTheme.createEnergyGlow(
                    color: widget.energyColor,
                    intensity: finalGlowIntensity,
                    radius: key.isPressed ? (8.0 + key.currentAftertouchValue * 8.0).clamp(8.0, 16.0) : 6.0,
                  ),
                ],
              ),
              child: Stack(
                clipBehavior: Clip.none,
                children: [
                  // Key label
                  Positioned(
                    bottom: 8,
                    left: 0,
                    right: 0,
                    child: Text(
                      key.noteName,
                      textAlign: TextAlign.center,
                      style: HolographicTheme.createHolographicText(
                        energyColor: key.isBlackKey 
                            ? widget.energyColor.withOpacity((0.8 - key.currentAftertouchValue * 0.3).clamp(0.5,0.8))
                            : widget.energyColor.withOpacity((0.7 - key.currentAftertouchValue * 0.3).clamp(0.4,0.7)),
                        fontSize: 10,
                      ),
                    ),
                  ),
                  
                  // Velocity/Aftertouch indicator (combined)
                  if (key.isPressed)
                    Positioned(
                      top: 4,
                      left: 4,
                      right: 4,
                      child: Opacity(
                        opacity: (key.velocity * 0.5 + key.currentAftertouchValue * 0.5).clamp(0.1, 1.0),
                        child: Container(
                          height: ((key.velocity * 1.5) + (key.currentAftertouchValue * 2.0)).clamp(1.0, 3.5),
                          decoration: BoxDecoration(
                            color: Color.lerp(widget.energyColor, Colors.white, key.currentAftertouchValue * 0.5),
                            borderRadius: BorderRadius.circular(1.5),
                            boxShadow: [
                              HolographicTheme.createEnergyGlow(
                                color: Color.lerp(widget.energyColor, Colors.white, key.currentAftertouchValue * 0.5)!,
                                radius: ((key.velocity * 1.0) + (key.currentAftertouchValue * 1.5)).clamp(1.0, 2.5),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  
                  // Hit Position Effect Painter
                  // Draw only if animation is running and position is available
                  if (_hitEffectAnimations[key.midiNote] != null &&
                      (_hitEffectControllers[key.midiNote]?.isAnimating ?? false) &&
                      key.lastTapDownPosition != null)
                    CustomPaint(
                      size: key.size,
                      painter: _KeyHitEffectPainter(
                        animationValue: _hitEffectAnimations[key.midiNote]!.value,
                        tapPosition: key.lastTapDownPosition!,
                        energyColor: widget.energyColor,
                        isBlackKey: key.isBlackKey,
                      ),
                    ),

                  // Drag handle for split mode
                  if (widget.splitMode)
                    Positioned(
                      top: 4,
                      right: 4,
                      child: Icon(
                        Icons.drag_indicator,
                        color: widget.energyColor.withOpacity(0.5),
                        size: 12,
                      ),
                    ),
                ],
              ),
            );
          },
        ),
      ),
    );
  }
  
  Widget _buildPitchWheel() {
    return Positioned(
      left: _pitchWheelPosition.dx,
      top: _pitchWheelPosition.dy,
      child: GestureDetector(
        onPanUpdate: (details) {
          setState(() {
            _pitchWheelPosition += details.delta;
            _pitchBendValue = (_pitchWheelPosition.dy - 100) / 50;
            _pitchBendValue = _pitchBendValue.clamp(-1.0, 1.0);
          });
          widget.onPitchBend?.call(_pitchBendValue);
        },
        child: Container(
          width: 30,
          height: 100,
          decoration: HolographicTheme.createHolographicBorder(
            energyColor: HolographicTheme.warningEnergy,
            cornerRadius: 15,
          ),
          child: Stack(
            children: [
              // Background track
              Positioned(
                left: 10,
                top: 10,
                bottom: 10,
                child: Container(
                  width: 10,
                  decoration: BoxDecoration(
                    color: HolographicTheme.warningEnergy.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(5),
                  ),
                ),
              ),
              
              // Thumb
              Positioned(
                left: 5,
                top: 45 + (_pitchBendValue * 20),
                child: Container(
                  width: 20,
                  height: 10,
                  decoration: BoxDecoration(
                    color: HolographicTheme.warningEnergy,
                    borderRadius: BorderRadius.circular(5),
                    boxShadow: [
                      HolographicTheme.createEnergyGlow(
                        color: HolographicTheme.warningEnergy,
                        radius: 4.0,
                      ),
                    ],
                  ),
                ),
              ),
              
              // Label
              Positioned(
                bottom: 2,
                left: 0,
                right: 0,
                child: Text(
                  'PITCH',
                  textAlign: TextAlign.center,
                  style: HolographicTheme.createHolographicText(
                    energyColor: HolographicTheme.warningEnergy,
                    fontSize: 8,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildModWheel() {
    return Positioned(
      left: _modWheelPosition.dx,
      top: _modWheelPosition.dy,
      child: GestureDetector(
        onPanUpdate: (details) {
          setState(() {
            _modWheelPosition += details.delta;
            _modulationValue = (100 - _modWheelPosition.dy) / 100;
            _modulationValue = _modulationValue.clamp(0.0, 1.0);
          });
          widget.onModulation?.call(_modulationValue);
        },
        child: Container(
          width: 30,
          height: 100,
          decoration: HolographicTheme.createHolographicBorder(
            energyColor: HolographicTheme.successEnergy,
            cornerRadius: 15,
          ),
          child: Stack(
            children: [
              // Background track
              Positioned(
                left: 10,
                top: 10,
                bottom: 10,
                child: Container(
                  width: 10,
                  decoration: BoxDecoration(
                    color: HolographicTheme.successEnergy.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(5),
                  ),
                ),
              ),
              
              // Thumb
              Positioned(
                left: 5,
                top: 80 - (_modulationValue * 70),
                child: Container(
                  width: 20,
                  height: 10,
                  decoration: BoxDecoration(
                    color: HolographicTheme.successEnergy,
                    borderRadius: BorderRadius.circular(5),
                    boxShadow: [
                      HolographicTheme.createEnergyGlow(
                        color: HolographicTheme.successEnergy,
                        radius: 4.0,
                      ),
                    ],
                  ),
                ),
              ),
              
              // Label
              Positioned(
                bottom: 2,
                left: 0,
                right: 0,
                child: Text(
                  'MOD',
                  textAlign: TextAlign.center,
                  style: HolographicTheme.createHolographicText(
                    energyColor: HolographicTheme.successEnergy,
                    fontSize: 8,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// Custom painter for key hit effect
class _KeyHitEffectPainter extends CustomPainter {
  final double animationValue; // 0.0 (start) to 1.0 (end of effect)
  final Offset tapPosition;    // Local X, Y on the key where tap occurred
  final Color energyColor;
  final bool isBlackKey;

  _KeyHitEffectPainter({
    required this.animationValue,
    required this.tapPosition,
    required this.energyColor,
    this.isBlackKey = false,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..style = PaintingStyle.fill;

    // Effect: A quick, bright flare that expands and fades.
    // animationValue goes from 0.0 (start) to 1.0 (end).

    // Opacity: Strongest at start, fades out.
    // Using (1-t)^2 curve for faster fade initially, slower at the end.
    final double opacity = math.pow(1.0 - animationValue, 2).toDouble();

    // Radius: Expands quickly.
    final double effectProgress = animationValue;
    final double maxRadius = size.width * (isBlackKey ? 0.3 : 0.25);
    final double currentRadius = maxRadius * effectProgress;

    // Core bright flare
    paint.color = Colors.white.withOpacity((opacity * 0.8).clamp(0.0, 1.0)); // Bright white core
    canvas.drawCircle(tapPosition, currentRadius * 0.5, paint);

    // Colored energy glow around the core
    paint.color = energyColor.withOpacity((opacity * 0.6).clamp(0.0, 1.0));
    canvas.drawCircle(tapPosition, currentRadius, paint);

    // Optional: subtle shockwave lines emanating outwards
    if (animationValue < 0.5) { // Only for the first half of the animation
      final shockwavePaint = Paint()
        ..color = energyColor.withOpacity((opacity * 0.4).clamp(0.0, 1.0))
        ..style = PaintingStyle.stroke
        ..strokeWidth = (1.5 * (1.0 - (animationValue / 0.5))).clamp(0.5, 1.5); // Thicker at start

      for (int i = 0; i < 2; i++) { // Draw 2 shockwave lines
        double shockRadius = currentRadius + (i * 4.0) * (animationValue / 0.5);
         if (shockRadius < size.width * 0.7) {
             canvas.drawCircle(tapPosition, shockRadius, shockwavePaint);
        }
      }
    }
  }

  @override
  bool shouldRepaint(covariant _KeyHitEffectPainter oldDelegate) {
    return oldDelegate.animationValue != animationValue ||
           oldDelegate.tapPosition != tapPosition ||
           oldDelegate.energyColor != energyColor ||
           oldDelegate.isBlackKey != isBlackKey;
  }
}