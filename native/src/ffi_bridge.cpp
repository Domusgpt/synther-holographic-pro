#include "ffi_bridge.hh" // Ensure this matches the actual header filename if it was .h or .hpp
#include "synth_engine.h"
#include <iostream>
#include <vector>
#include <string>
#include <cstring> // For strdup if used, or for string manipulation

// --- Global static variables for MIDI callback and device list ---
typedef void (*MidiMessageCallback)(const unsigned char*, int); // For raw MIDI messages
static MidiMessageCallback g_midi_message_callback = nullptr;

typedef void (*ParameterChangeCallback)(int, float); // For automation-driven parameter changes
static ParameterChangeCallback g_dart_parameter_change_callback = nullptr;

// Typedef for the new UI Control MIDI Callback from Dart
typedef void (*UiControlMidiCallbackDart)(int targetPanelId, int ccNumber, int ccValue);
static UiControlMidiCallbackDart g_dart_ui_control_midi_callback = nullptr;

// Mock MIDI device list JSON string
// In a real scenario, this would be dynamically generated by querying system MIDI services.
// IMPORTANT: The memory for this string must be managed carefully if not static const.
// For FFI, returning c_str() of a static std::string is generally okay if Dart copies it immediately.
static const std::string midi_devices_json_str =
    "[{\"name\": \"Virtual MIDI Keyboard\", \"id\": \"virtual_0\"},"
    " {\"name\": \"USB MIDI Interface\", \"id\": \"usb_1\"},"
    " {\"name\": \"Bluetooth MIDI Thingy\", \"id\": \"bt_midi_2\"}]";


// Implementation of the FFI bridge functions

int InitializeSynthEngine(int sampleRate, int bufferSize, float initialVolume) {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (engine.initialize(sampleRate, bufferSize, initialVolume)) {
            return 0; // Success
        } else {
            return -1; // Failed to initialize
        }
    } catch (const std::exception& e) {
        std::cerr << "Exception in InitializeSynthEngine: " << e.what() << std::endl;
        return -2; // Exception occurred
    } catch (...) {
        std::cerr << "Unknown exception in InitializeSynthEngine" << std::endl;
        return -3; // Unknown exception
    }
}

FFI_BRIDGE_EXPORT void set_xy_pad_x_parameter_ffi(int32_t parameter_id) {
    try {
        SynthEngine::getInstance().setXYPadXParameter(parameter_id);
    } catch (const std::exception& e) {
        std::cerr << "Exception in set_xy_pad_x_parameter_ffi: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception in set_xy_pad_x_parameter_ffi" << std::endl;
    }
}

FFI_BRIDGE_EXPORT void set_xy_pad_y_parameter_ffi(int32_t parameter_id) {
    try {
        SynthEngine::getInstance().setXYPadYParameter(parameter_id);
    } catch (const std::exception& e) {
        std::cerr << "Exception in set_xy_pad_y_parameter_ffi: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception in set_xy_pad_y_parameter_ffi" << std::endl;
    }
}

FFI_BRIDGE_EXPORT void free_preset_json_ffi(char* json_string) {
    if (json_string) {
        delete[] json_string;
    }
}

void ShutdownSynthEngine() {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        engine.shutdown();
    } catch (const std::exception& e) {
        std::cerr << "Exception in ShutdownSynthEngine: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception in ShutdownSynthEngine" << std::endl;
    }
}

int ProcessMidiEvent(unsigned char status, unsigned char data1, unsigned char data2) {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return -1; // Engine not initialized
        }

        // If a Dart callback is registered, send the raw MIDI message to it first.
        if (g_midi_message_callback != nullptr) {
            unsigned char message[3] = {status, data1, data2};
            // Determine actual length based on message type if necessary, for CC it's 3.
            // For NoteOn/Off it's 3. SysEx would be different.
            // For simplicity, sending 3 bytes for typical channel messages.
            int length = 3;
            // For SysEx, status byte itself indicates start, and 0xF7 indicates end.
            // For common messages:
            if ((status & 0xF0) == 0xC0 || (status & 0xF0) == 0xD0) { // Program Change, Channel Aftertouch
                length = 2;
            }
            g_midi_message_callback(message, length);
        }
        
        if (engine.processMidiEvent(status, data1, data2)) {
            return 0; // Success
        } else {
            return -2; // Failed to process event (e.g. unhandled MIDI message type by engine)
        }
    } catch (const std::exception& e) {
        std::cerr << "Exception in ProcessMidiEvent: " << e.what() << std::endl;
        return -3; // Exception occurred
    } catch (...) {
        std::cerr << "Unknown exception in ProcessMidiEvent" << std::endl;
        return -4; // Unknown exception
    }
}

int SetParameter(int parameterId, float value) {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return -1; // Engine not initialized
        }
        
        if (engine.setParameter(parameterId, value)) {
            return 0; // Success
        } else {
            return -2; // Failed to set parameter
        }
    } catch (const std::exception& e) {
        std::cerr << "Exception in SetParameter: " << e.what() << std::endl;
        return -3; // Exception occurred
    } catch (...) {
        std::cerr << "Unknown exception in SetParameter" << std::endl;
        return -4; // Unknown exception
    }
}

float GetParameter(int parameterId) {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return 0.0f; // Engine not initialized, return default
        }
        
        return engine.getParameter(parameterId);
    } catch (const std::exception& e) {
        std::cerr << "Exception in GetParameter: " << e.what() << std::endl;
        return 0.0f; // Exception occurred, return default
    } catch (...) {
        std::cerr << "Unknown exception in GetParameter" << std::endl;
        return 0.0f; // Unknown exception, return default
    }
}

int NoteOn(int note, int velocity) {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return -1; // Engine not initialized
        }
        
        if (engine.noteOn(note, velocity)) {
            return 0; // Success
        } else {
            return -2; // Failed to process note-on
        }
    } catch (const std::exception& e) {
        std::cerr << "Exception in NoteOn: " << e.what() << std::endl;
        return -3; // Exception occurred
    } catch (...) {
        std::cerr << "Unknown exception in NoteOn" << std::endl;
        return -4; // Unknown exception
    }
}

int NoteOff(int note) {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return -1; // Engine not initialized
        }
        
        if (engine.noteOff(note)) {
            return 0; // Success
        } else {
            return -2; // Failed to process note-off
        }
    } catch (const std::exception& e) {
        std::cerr << "Exception in NoteOff: " << e.what() << std::endl;
        return -3; // Exception occurred
    } catch (...) {
        std::cerr << "Unknown exception in NoteOff" << std::endl;
        return -4; // Unknown exception
    }
}

int LoadGranularBuffer(const float* buffer, int length) {
    try {
        if (!buffer || length <= 0) {
            return -1; // Invalid parameters
        }
        
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return -2; // Engine not initialized
        }
        
        // Copy buffer data to a vector
        std::vector<float> audioData(buffer, buffer + length);
        
        // Load into granular synth through engine
        if (engine.loadGranularBuffer(audioData)) {
            return 0; // Success
        } else {
            return -3; // Failed to load buffer
        }
    } catch (const std::exception& e) {
        std::cerr << "Exception in LoadGranularBuffer: " << e.what() << std::endl;
        return -4; // Exception occurred
    } catch (...) {
        std::cerr << "Unknown exception in LoadGranularBuffer" << std::endl;
        return -5; // Unknown exception
    }
}

// Audio analysis functions for visualization
double GetBassLevel() {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return 0.0; // Engine not initialized
        }
        return engine.getBassLevel();
    } catch (const std::exception& e) {
        std::cerr << "Exception in GetBassLevel: " << e.what() << std::endl;
        return 0.0;
    } catch (...) {
        std::cerr << "Unknown exception in GetBassLevel" << std::endl;
        return 0.0;
    }
}

// --- New FFI Functions for MIDI Device Handling & Learn ---

FFI_BRIDGE_EXPORT const char* get_midi_devices_json() {
    // NOTE: Returning c_str() of a static std::string.
    // Dart side should copy this string immediately if it needs to persist it,
    // as the pointer might not be valid indefinitely (though for a static string it is).
    // A more robust method might involve Dart allocating memory and C++ filling it.
    return midi_devices_json_str.c_str();
}

FFI_BRIDGE_EXPORT void select_midi_device(const char* device_id) {
    if (device_id) {
        std::cout << "FFI: MIDI Device selected: " << device_id << std::endl;
        // TODO: Here, you would typically pass this to a MIDI handling library
        // to open the specified device for input.
        // For now, it's just a log.
    } else {
        std::cerr << "FFI: select_midi_device called with null device_id" << std::endl;
    }
}

FFI_BRIDGE_EXPORT void register_midi_message_callback(MidiMessageCallback callback_ptr) {
    std::cout << "FFI: register_midi_message_callback called." << std::endl;
    g_midi_message_callback = callback_ptr;
}

FFI_BRIDGE_EXPORT void start_midi_learn_ffi(int parameter_id) {
    try {
        SynthEngine::getInstance().startMidiLearn(parameter_id);
    } catch (const std::exception& e) {
        std::cerr << "Exception in start_midi_learn_ffi: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception in start_midi_learn_ffi" << std::endl;
    }
}

FFI_BRIDGE_EXPORT void stop_midi_learn_ffi() {
    try {
        SynthEngine::getInstance().stopMidiLearn();
    } catch (const std::exception& e) {
        std::cerr << "Exception in stop_midi_learn_ffi: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception in stop_midi_learn_ffi" << std::endl;
    }
}

// --- Automation FFI Functions ---

FFI_BRIDGE_EXPORT void start_automation_recording_ffi() {
    try {
        SynthEngine::getInstance().startAutomationRecording();
    } catch (const std::exception& e) {
        std::cerr << "Exception in start_automation_recording_ffi: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception in start_automation_recording_ffi" << std::endl;
    }
}

FFI_BRIDGE_EXPORT void stop_automation_recording_ffi() {
    try {
        SynthEngine::getInstance().stopAutomationRecording();
    } catch (const std::exception& e) {
        std::cerr << "Exception in stop_automation_recording_ffi: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception in stop_automation_recording_ffi" << std::endl;
    }
}

FFI_BRIDGE_EXPORT void start_automation_playback_ffi() {
    try {
        SynthEngine::getInstance().startAutomationPlayback();
    } catch (const std::exception& e) {
        std::cerr << "Exception in start_automation_playback_ffi: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception in start_automation_playback_ffi" << std::endl;
    }
}

FFI_BRIDGE_EXPORT void stop_automation_playback_ffi() {
    try {
        SynthEngine::getInstance().stopAutomationPlayback();
    } catch (const std::exception& e) {
        std::cerr << "Exception in stop_automation_playback_ffi: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception in stop_automation_playback_ffi" << std::endl;
    }
}

FFI_BRIDGE_EXPORT void clear_automation_data_ffi() {
    try {
        SynthEngine::getInstance().clearAutomationData();
    } catch (const std::exception& e) {
        std::cerr << "Exception in clear_automation_data_ffi: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception in clear_automation_data_ffi" << std::endl;
    }
}

FFI_BRIDGE_EXPORT bool has_automation_data_ffi() {
    try {
        return SynthEngine::getInstance().hasAutomationData();
    } catch (const std::exception& e) {
        std::cerr << "Exception in has_automation_data_ffi: " << e.what() << std::endl;
        return false;
    } catch (...) {
        std::cerr << "Unknown exception in has_automation_data_ffi" << std::endl;
        return false;
    }
}

FFI_BRIDGE_EXPORT bool is_automation_recording_ffi() {
    try {
        return SynthEngine::getInstance().isRecordingAutomation.load();
    } catch (const std::exception& e) {
        std::cerr << "Exception in is_automation_recording_ffi: " << e.what() << std::endl;
        return false;
    } catch (...) {
        std::cerr << "Unknown exception in is_automation_recording_ffi" << std::endl;
        return false;
    }
}

FFI_BRIDGE_EXPORT bool is_automation_playing_ffi() {
    try {
        return SynthEngine::getInstance().isPlayingAutomation.load();
    } catch (const std::exception& e) {
        std::cerr << "Exception in is_automation_playing_ffi: " << e.what() << std::endl;
        return false;
    } catch (...) {
        std::cerr << "Unknown exception in is_automation_playing_ffi" << std::endl;
        return false;
    }
}

FFI_BRIDGE_EXPORT void register_parameter_change_callback_ffi(ParameterChangeCallback callback_ptr) {
    std::cout << "FFI: register_parameter_change_callback_ffi called." << std::endl;
    g_dart_parameter_change_callback = callback_ptr;

    if (callback_ptr) {
        auto cppCallback = [](int paramId, float value) {
            if (g_dart_parameter_change_callback) {
                g_dart_parameter_change_callback(paramId, value);
            }
        };
        SynthEngine::getInstance().setParameterChangeCallback(cppCallback);
    } else {
        SynthEngine::getInstance().setParameterChangeCallback(nullptr); // Clear callback
    }
}

// Trampoline function to call the Dart callback for UI MIDI control
static void cpp_ui_control_midi_callback_trampoline(int targetPanelId, int ccNumber, int ccValue) {
    if (g_dart_ui_control_midi_callback) {
        g_dart_ui_control_midi_callback(targetPanelId, ccNumber, ccValue);
    }
}

FFI_BRIDGE_EXPORT void register_ui_control_midi_callback(UiControlMidiCallbackDart callback_ptr) {
    std::cout << "FFI: register_ui_control_midi_callback called." << std::endl;
    g_dart_ui_control_midi_callback = callback_ptr;

    if (callback_ptr) {
        SynthEngine::getInstance().setUiControlMidiCallback(cpp_ui_control_midi_callback_trampoline);
    } else {
        SynthEngine::getInstance().setUiControlMidiCallback(nullptr); // Clear callback
    }
}


// --- Preset Management FFI Functions ---

FFI_BRIDGE_EXPORT const char* get_current_preset_json_ffi(const char* name_c_str) {
    if (!name_c_str) {
        // Or handle error, return null or an error JSON
        return strdup("{\"error\":\"Preset name is null\"}");
    }
    std::string presetName = name_c_str; // Assuming name_c_str is just the name, not JSON

    try {
        std::string presetJson = SynthEngine::getInstance().getCurrentPresetDataJson(presetName);
        // IMPORTANT: Dart needs to free this memory using ffi.calloc.free() or equivalent
        // for the Pointer<Utf8> it receives.
        char* cJson = new char[presetJson.length() + 1];
        std::strcpy(cJson, presetJson.c_str());
        return cJson;
        // A common alternative is strdup, but it uses malloc, ensure Dart frees with correct allocator.
        // return strdup(presetJson.c_str());
    } catch (const std::exception& e) {
        std::cerr << "Exception in get_current_preset_json_ffi: " << e.what() << std::endl;
        // Return an error JSON
        std::string errorJson = "{\"error\":\"Failed to get preset: " + std::string(e.what()) + "\"}";
        char* cErrorJson = new char[errorJson.length() + 1];
        std::strcpy(cErrorJson, errorJson.c_str());
        return cErrorJson;
    } catch (...) {
        std::cerr << "Unknown exception in get_current_preset_json_ffi" << std::endl;
        char* cErrorJson = new char[50]; // A simple error message buffer
        std::strcpy(cErrorJson, "{\"error\":\"Unknown error getting preset\"}");
        return cErrorJson;
    }
}

FFI_BRIDGE_EXPORT int apply_preset_json_ffi(const char* preset_json_c_str) {
    if (!preset_json_c_str) {
        return -1; // Invalid argument
    }
    std::string presetJsonStdStr = preset_json_c_str;
    try {
        if (SynthEngine::getInstance().applyPresetDataJson(presetJsonStdStr)) {
            return 0; // Success
        } else {
            return -2; // Failed to apply preset in engine
        }
    } catch (const std::exception& e) {
        std::cerr << "Exception in apply_preset_json_ffi: " << e.what() << std::endl;
        return -3; // Exception occurred
    } catch (...) {
        std::cerr << "Unknown exception in apply_preset_json_ffi" << std::endl;
        return -4; // Unknown exception
    }
}


double GetMidLevel() {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return 0.0; // Engine not initialized
        }
        return engine.getMidLevel();
    } catch (const std::exception& e) {
        std::cerr << "Exception in GetMidLevel: " << e.what() << std::endl;
        return 0.0;
    } catch (...) {
        std::cerr << "Unknown exception in GetMidLevel" << std::endl;
        return 0.0;
    }
}

double GetHighLevel() {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return 0.0; // Engine not initialized
        }
        return engine.getHighLevel();
    } catch (const std::exception& e) {
        std::cerr << "Exception in GetHighLevel: " << e.what() << std::endl;
        return 0.0;
    } catch (...) {
        std::cerr << "Unknown exception in GetHighLevel" << std::endl;
        return 0.0;
    }
}

double GetAmplitudeLevel() {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return 0.0; // Engine not initialized
        }
        return engine.getAmplitudeLevel();
    } catch (const std::exception& e) {
        std::cerr << "Exception in GetAmplitudeLevel: " << e.what() << std::endl;
        return 0.0;
    } catch (...) {
        std::cerr << "Unknown exception in GetAmplitudeLevel" << std::endl;
        return 0.0;
    }
}

double GetDominantFrequency() {
    try {
        SynthEngine& engine = SynthEngine::getInstance();
        if (!engine.isInitialized()) {
            return 0.0; // Engine not initialized
        }
        return engine.getDominantFrequency();
    } catch (const std::exception& e) {
        std::cerr << "Exception in GetDominantFrequency: " << e.what() << std::endl;
        return 0.0;
    } catch (...) {
        std::cerr << "Unknown exception in GetDominantFrequency" << std::endl;
        return 0.0;
    }
}